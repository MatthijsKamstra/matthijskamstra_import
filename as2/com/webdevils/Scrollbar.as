import mx.utils.Delegate;/** * Simple Scrollbar Class *  *  * Here’s a simple AS 2.0 Class that creates a scrollbar.  * The ScrollBar class takes two parameters.  * The name of the movie clip that will act as the scrollbar and the name of a function the scrollbar will call when it is dragged. *  * new ScrollBar( target_mc, callBack ); *  * The target_mc must have two clips inside named drag_mc and track_mc.  * The first is the dragger and the second sets the limits for the dragger.  * You can design these in any way you like as long as they use the instance names *  *    *  * drag_mc *  * track_mc *  * For best results place the registration points of both clips in the upper left corner and align both clips within their parent. *  * The callback can be any function name that you have defined.  * The ScrollBar class will send a value from 0 to 1 to the callback that gives the percentage position of drag_mc from the top of track_mc. *  * For example if you made a clip with both drag_mc and track_mc you might give that clip the instance name of scroll_mc. To make a new instance of ScrollBar you could use the following: *  * var a_scrollbar:Scrollbar = new Scrollbar( scroll_mc, test ); *  * When the scrollbar is dragged the function test would be called and passed a value between 0 and 1 representing the position of the dragger.  * You could use this to scroll some text in a dynamic text field or set the volume of a sound object. *  * Here is a sample function that would scroll a dynamic text field named scroll_txt: *  * function test( n ) { *	 scroll_txt.scroll = Math.round( ( scroll_txt.maxscroll - 1 ) * n ) + 1; *	} * * Simple Scrollbar ClassHere’s an example of the scrollbar in action.Scrollbar( host_mc:MovieClip, call_back_func:Function )Creates a new Instance of Scrollbar. The host_mc clip must contain two clips named drag_mc and track_mc. These clips act as the scrollbar. track_mc sets the limits while drag_mc is the interactive clip.The call back function can be the name of any function you define. It will receive one parameter, a value representing how far the scrollbar is scrolled. The range of the returned value will be from 0.0 to 1.0. With 0.0 being the value returned when the scrollbar is at the top (or left when scrolling horizontally) and 1.0 when the scrollbar is at the bottom (or right). You can use this value to control elements in your movie.    * host_mc: a movie clip containing the drag_mc and track_mc.    * call_back: the name of a function that will be called when the scrollbar is scrolled.scroll_horizontal( horizontal_scroll:Boolean )This method determines whether the scrollbar scrolls vertical or horizontal. By default the scrollbar scrolls vertically. Calling scroll_horizontal() and passing true makes the scrollbar scroll horizontally.getValue():NumberThe method returns the current value of the scrollbar.setValue( n:Number )The method sets the current position of the scrollbar. Pass a value of 0 to 100.Property enabledThis property enables and disables the scrollbar. *  *  *  *  * Example:var thisObj = this;function positionDisclaimer( n ) {	// trace( n );	var scrollHeightMovie : Number = thisObj.content_mc._height - thisObj.scroll_mc._height ;	thisObj.content_mc._y = thisObj.scroll_mc._y  - (scrollHeightMovie * n );}var a_scrollbar:com.webdevils.Scrollbar = new com.webdevils.Scrollbar( scroll_mc, thisObj.positionDisclaimer ); *  *  * Documentation * http://www.webdevils.com/?p=7 *  *  *  * @author  MatthijsK * @version  * 			r1.0 - intial release by webdevils * 			r1.1 - extra arguments for classes * 	 * @since    */class com.webdevils.Scrollbar {		private var target_mc:MovieClip;	private var track_mc:MovieClip;	private var drag_mc:MovieClip;	private var call_back:Function;		private var range:Number;	private var t_limit:Number;	private var b_limit:Number;	private var l_limit:Number;	private var r_limit:Number;	private var min_limit:Number;	private var max_limit:Number;		private var my_enabled:Boolean;	private var horizontal_scroll:Boolean = false;		public var percent:Number;		private var extraArgs : Array ;		/**	 * constructor	 * 	 * @usage		new com.webdevils.Scrollbar ( target_mc, callBack )	 * 	 * @param   	host_mc				a movie clip containing the drag_mc and track_mc.     * @param   	call_back_func		the name of a function that will be called when the scrollbar is scrolled.	 */	public function Scrollbar( host_mc:MovieClip, call_back_func:Function ) {		target_mc = host_mc;		track_mc = host_mc.track_mc;		drag_mc  = host_mc.drag_mc;		call_back = call_back_func;		// Get any extra arguments for handler		extraArgs = arguments.slice (2);				get_limits();				drag_mc.onPress = Delegate.create( this, drag );		drag_mc.onRelease = drag_mc.onReleaseOutside = Delegate.create( this, endDrag );	}	/**	 * scroll horizontal	 * 	 * @usage   	var temp = new com.webdevils.Scrollbar ( target_mc, callBack )	 * 				temp.scroll_horizontal(true )	 * @param		b 	true or false 	 * @return  	 */	public function scroll_horizontal( b:Boolean ):Void {		horizontal_scroll = b;		get_limits();	}		/**	 * return the current value (between 0 and 1)	 * 	 * @usage   	 * @return  	number between 0 and 1	 */	public function getValue():Number {		return percent;	}		/**	 * start with another value	 * 	 * @usage  		var sb = new com.webdevils.Scrollbar ( target_mc, callBack )	 * 				sb.setValue(50 );	 * @param   n 		value between 0 and 100 (???)	 * @return  	 */	public function setValue( n:Number ):Void {		percent = n / 100;		if ( horizontal_scroll ) {			drag_mc._x = l_limit + ( percent * range );		} else {			drag_mc._y = t_limit + ( percent * range );		}		call_back( percent,extraArgs ); 	}			/**	 * Enter description here	 * 	 * @usage   	 * @param   b 	 * @return  	 */	public function set enabled( b:Boolean ):Void {		my_enabled = b;		drag_mc.enabled = b;		track_mc.enabled = b;	}		/**	 * Enter description here	 * 	 * @usage   	 * @return  	 */	public function get enabled():Boolean {		return my_enabled;	}			/////////		private function get_limits():Void {		var track_bounds = track_mc.getBounds( target_mc );		if ( horizontal_scroll ) {			l_limit = track_bounds.xMin;			r_limit = track_bounds.xMax - track_bounds.xMin - drag_mc._width;			t_limit = 0;			b_limit = 0;			range = r_limit - l_limit;		} else {			t_limit = track_bounds.yMin;			b_limit = track_bounds.yMax - track_bounds.yMin - drag_mc._height;			l_limit = 0;			r_limit = 0			range = b_limit - t_limit;		}	}		private function drag():Void {		drag_mc.startDrag( false, l_limit, t_limit, r_limit, b_limit );		drag_mc.onMouseMove = Delegate.create( this, calculate_percent );	}		private function endDrag():Void {		drag_mc.stopDrag();		delete drag_mc.onMouseMove;	}			private function calculate_percent():Void {		if ( horizontal_scroll ) {			percent = ( drag_mc._x - l_limit ) / range;		} else {			percent = ( drag_mc._y - t_limit ) / range;		}		call_back( percent , extraArgs );	}		} // end